/**
 * ResourceManagementController
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { CoreModelsResourceManagementAuditLogGetResourceManagementAuditLogsByConditionRequest } from '../model/coreModelsResourceManagementAuditLogGetResourceManagementAuditLogsByConditionRequest';
import { CoreModelsResourceManagementAuditLogGetResourceManagementAuditLogsByConditionResponse } from '../model/coreModelsResourceManagementAuditLogGetResourceManagementAuditLogsByConditionResponse';
import { CoreModelsResourceManagementHolidayCreateOrUpdateHolidayRequest } from '../model/coreModelsResourceManagementHolidayCreateOrUpdateHolidayRequest';
import { CoreModelsResourceManagementHolidayCreateOrUpdateHolidayResponse } from '../model/coreModelsResourceManagementHolidayCreateOrUpdateHolidayResponse';
import { CoreModelsResourceManagementHolidayDeleteDeleteHolidayRequest } from '../model/coreModelsResourceManagementHolidayDeleteDeleteHolidayRequest';
import { CoreModelsResourceManagementHolidayDeleteDeleteHolidayResponse } from '../model/coreModelsResourceManagementHolidayDeleteDeleteHolidayResponse';
import { CoreModelsResourceManagementHolidayGetAllHolidaysByConditionRequest } from '../model/coreModelsResourceManagementHolidayGetAllHolidaysByConditionRequest';
import { CoreModelsResourceManagementHolidayGetAllHolidaysByConditionResponse } from '../model/coreModelsResourceManagementHolidayGetAllHolidaysByConditionResponse';
import { CoreModelsResourceManagementHolidayHolidayAPIHolidayAPIRequest } from '../model/coreModelsResourceManagementHolidayHolidayAPIHolidayAPIRequest';
import { CoreModelsResourceManagementHolidayHolidayAPIHolidayAPIResponse } from '../model/coreModelsResourceManagementHolidayHolidayAPIHolidayAPIResponse';
import { CoreModelsResourceManagementPlannedScheduleCreateOrUpdatePlannedScheduleRequest } from '../model/coreModelsResourceManagementPlannedScheduleCreateOrUpdatePlannedScheduleRequest';
import { CoreModelsResourceManagementPlannedScheduleCreateOrUpdatePlannedScheduleResponse } from '../model/coreModelsResourceManagementPlannedScheduleCreateOrUpdatePlannedScheduleResponse';
import { CoreModelsResourceManagementPlannedScheduleDeleteDeletePlannedScheduleRequest } from '../model/coreModelsResourceManagementPlannedScheduleDeleteDeletePlannedScheduleRequest';
import { CoreModelsResourceManagementPlannedScheduleDeleteDeletePlannedScheduleResponse } from '../model/coreModelsResourceManagementPlannedScheduleDeleteDeletePlannedScheduleResponse';
import { CoreModelsResourceManagementPlannedScheduleGetPlannedScheduleByConditionRequest } from '../model/coreModelsResourceManagementPlannedScheduleGetPlannedScheduleByConditionRequest';
import { CoreModelsResourceManagementPlannedScheduleGetPlannedScheduleByConditionResponse } from '../model/coreModelsResourceManagementPlannedScheduleGetPlannedScheduleByConditionResponse';
import { CoreModelsResourceManagementPlannedScheduleInitPageGetPlannedScheduleInitPageRequest } from '../model/coreModelsResourceManagementPlannedScheduleInitPageGetPlannedScheduleInitPageRequest';
import { CoreModelsResourceManagementPlannedScheduleInitPageGetPlannedScheduleInitPageResponse } from '../model/coreModelsResourceManagementPlannedScheduleInitPageGetPlannedScheduleInitPageResponse';
import { CoreModelsResourceManagementPlannedScheduleWarningCheckPlannedScheduleRequest } from '../model/coreModelsResourceManagementPlannedScheduleWarningCheckPlannedScheduleRequest';
import { CoreModelsResourceManagementPlannedScheduleWarningCheckPlannedScheduleResponse } from '../model/coreModelsResourceManagementPlannedScheduleWarningCheckPlannedScheduleResponse';
import { CoreModelsResourceManagementPlannedScheduleWarningDeleteDeletePlannedScheduleWarningRequest } from '../model/coreModelsResourceManagementPlannedScheduleWarningDeleteDeletePlannedScheduleWarningRequest';
import { CoreModelsResourceManagementPlannedScheduleWarningDeleteDeletePlannedScheduleWarningResponse } from '../model/coreModelsResourceManagementPlannedScheduleWarningDeleteDeletePlannedScheduleWarningResponse';
import { CoreModelsResourceManagementPlannedScheduleWarningGetPlannedScheduleWarningByConditionRequest } from '../model/coreModelsResourceManagementPlannedScheduleWarningGetPlannedScheduleWarningByConditionRequest';
import { CoreModelsResourceManagementPlannedScheduleWarningGetPlannedScheduleWarningByConditionResponse } from '../model/coreModelsResourceManagementPlannedScheduleWarningGetPlannedScheduleWarningByConditionResponse';
import { CoreModelsResourceManagementPlannedScheduleWarningInitPageGetPlannedScheduleWarningInitPageRequest } from '../model/coreModelsResourceManagementPlannedScheduleWarningInitPageGetPlannedScheduleWarningInitPageRequest';
import { CoreModelsResourceManagementPlannedScheduleWarningInitPageGetPlannedScheduleWarningInitPageResponse } from '../model/coreModelsResourceManagementPlannedScheduleWarningInitPageGetPlannedScheduleWarningInitPageResponse';
import { CoreModelsResourceManagementPublishedScheduleCreateOrUpdatePublishedScheduleRequest } from '../model/coreModelsResourceManagementPublishedScheduleCreateOrUpdatePublishedScheduleRequest';
import { CoreModelsResourceManagementPublishedScheduleCreateOrUpdatePublishedScheduleResponse } from '../model/coreModelsResourceManagementPublishedScheduleCreateOrUpdatePublishedScheduleResponse';
import { CoreModelsResourceManagementPublishedScheduleDeleteDeletePublishedScheduleRequest } from '../model/coreModelsResourceManagementPublishedScheduleDeleteDeletePublishedScheduleRequest';
import { CoreModelsResourceManagementPublishedScheduleDeleteDeletePublishedScheduleResponse } from '../model/coreModelsResourceManagementPublishedScheduleDeleteDeletePublishedScheduleResponse';
import { CoreModelsResourceManagementPublishedScheduleGetPublishedScheduleByConditionRequest } from '../model/coreModelsResourceManagementPublishedScheduleGetPublishedScheduleByConditionRequest';
import { CoreModelsResourceManagementPublishedScheduleGetPublishedScheduleByConditionResponse } from '../model/coreModelsResourceManagementPublishedScheduleGetPublishedScheduleByConditionResponse';
import { CoreModelsResourceManagementPublishedScheduleInitPageGetPublishedScheduleInitPageRequest } from '../model/coreModelsResourceManagementPublishedScheduleInitPageGetPublishedScheduleInitPageRequest';
import { CoreModelsResourceManagementPublishedScheduleInitPageGetPublishedScheduleInitPageResponse } from '../model/coreModelsResourceManagementPublishedScheduleInitPageGetPublishedScheduleInitPageResponse';
import { CoreModelsResourceManagementPublishedSchedulePublishingCreatePublishingRequest } from '../model/coreModelsResourceManagementPublishedSchedulePublishingCreatePublishingRequest';
import { CoreModelsResourceManagementPublishedSchedulePublishingCreatePublishingResponse } from '../model/coreModelsResourceManagementPublishedSchedulePublishingCreatePublishingResponse';
import { CoreModelsResourceManagementPublishedScheduleWarningCheckPublishedScheduleRequest } from '../model/coreModelsResourceManagementPublishedScheduleWarningCheckPublishedScheduleRequest';
import { CoreModelsResourceManagementPublishedScheduleWarningCheckPublishedScheduleResponse } from '../model/coreModelsResourceManagementPublishedScheduleWarningCheckPublishedScheduleResponse';
import { CoreModelsResourceManagementPublishedScheduleWarningDeleteDeletePublishedScheduleWarningRequest } from '../model/coreModelsResourceManagementPublishedScheduleWarningDeleteDeletePublishedScheduleWarningRequest';
import { CoreModelsResourceManagementPublishedScheduleWarningDeleteDeletePublishedScheduleWarningResponse } from '../model/coreModelsResourceManagementPublishedScheduleWarningDeleteDeletePublishedScheduleWarningResponse';
import { CoreModelsResourceManagementPublishedScheduleWarningGetPublishedScheduleWarningByConditionRequest } from '../model/coreModelsResourceManagementPublishedScheduleWarningGetPublishedScheduleWarningByConditionRequest';
import { CoreModelsResourceManagementPublishedScheduleWarningGetPublishedScheduleWarningByConditionResponse } from '../model/coreModelsResourceManagementPublishedScheduleWarningGetPublishedScheduleWarningByConditionResponse';
import { CoreModelsResourceManagementPublishedScheduleWarningInitPageGetPublishedScheduleWarningInitPageRequest } from '../model/coreModelsResourceManagementPublishedScheduleWarningInitPageGetPublishedScheduleWarningInitPageRequest';
import { CoreModelsResourceManagementPublishedScheduleWarningInitPageGetPublishedScheduleWarningInitPageResponse } from '../model/coreModelsResourceManagementPublishedScheduleWarningInitPageGetPublishedScheduleWarningInitPageResponse';
import { CoreModelsResourceManagementScheduleGeneratorGeneratePlannedScheduleRequest } from '../model/coreModelsResourceManagementScheduleGeneratorGeneratePlannedScheduleRequest';
import { CoreModelsResourceManagementScheduleGeneratorGeneratePlannedScheduleResponse } from '../model/coreModelsResourceManagementScheduleGeneratorGeneratePlannedScheduleResponse';
import { CoreModelsResourceManagementScheduleSubstituteEmployeesGetEmployeesForSubstitutionRequest } from '../model/coreModelsResourceManagementScheduleSubstituteEmployeesGetEmployeesForSubstitutionRequest';
import { CoreModelsResourceManagementScheduleSubstituteEmployeesGetEmployeesForSubstitutionResponse } from '../model/coreModelsResourceManagementScheduleSubstituteEmployeesGetEmployeesForSubstitutionResponse';
import { CoreModelsResourceManagementScheduleSubstituteEmployeesSubstituteEmployeesRequest } from '../model/coreModelsResourceManagementScheduleSubstituteEmployeesSubstituteEmployeesRequest';
import { CoreModelsResourceManagementScheduleSubstituteEmployeesSubstituteEmployeesResponse } from '../model/coreModelsResourceManagementScheduleSubstituteEmployeesSubstituteEmployeesResponse';
import { CoreModelsResourceManagementScheduleTemplateCreateOrUpdateScheduleTemplateItemRequest } from '../model/coreModelsResourceManagementScheduleTemplateCreateOrUpdateScheduleTemplateItemRequest';
import { CoreModelsResourceManagementScheduleTemplateCreateOrUpdateScheduleTemplateItemResponse } from '../model/coreModelsResourceManagementScheduleTemplateCreateOrUpdateScheduleTemplateItemResponse';
import { CoreModelsResourceManagementScheduleTemplateCreateOrUpdateScheduleTemplateRequest } from '../model/coreModelsResourceManagementScheduleTemplateCreateOrUpdateScheduleTemplateRequest';
import { CoreModelsResourceManagementScheduleTemplateCreateOrUpdateScheduleTemplateResponse } from '../model/coreModelsResourceManagementScheduleTemplateCreateOrUpdateScheduleTemplateResponse';
import { CoreModelsResourceManagementScheduleTemplateCreateScheduleFromTemplateRequest } from '../model/coreModelsResourceManagementScheduleTemplateCreateScheduleFromTemplateRequest';
import { CoreModelsResourceManagementScheduleTemplateCreateScheduleFromTemplateResponse } from '../model/coreModelsResourceManagementScheduleTemplateCreateScheduleFromTemplateResponse';
import { CoreModelsResourceManagementScheduleTemplateCreateTemplateFromPublishedScheduleRequest } from '../model/coreModelsResourceManagementScheduleTemplateCreateTemplateFromPublishedScheduleRequest';
import { CoreModelsResourceManagementScheduleTemplateCreateTemplateFromPublishedScheduleResponse } from '../model/coreModelsResourceManagementScheduleTemplateCreateTemplateFromPublishedScheduleResponse';
import { CoreModelsResourceManagementScheduleTemplateDeleteDeleteScheduleTemplateItemRequest } from '../model/coreModelsResourceManagementScheduleTemplateDeleteDeleteScheduleTemplateItemRequest';
import { CoreModelsResourceManagementScheduleTemplateDeleteDeleteScheduleTemplateItemResponse } from '../model/coreModelsResourceManagementScheduleTemplateDeleteDeleteScheduleTemplateItemResponse';
import { CoreModelsResourceManagementScheduleTemplateDeleteDeleteScheduleTemplateRequest } from '../model/coreModelsResourceManagementScheduleTemplateDeleteDeleteScheduleTemplateRequest';
import { CoreModelsResourceManagementScheduleTemplateDeleteDeleteScheduleTemplateResponse } from '../model/coreModelsResourceManagementScheduleTemplateDeleteDeleteScheduleTemplateResponse';
import { CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateByConditionRequest } from '../model/coreModelsResourceManagementScheduleTemplateGetScheduleTemplateByConditionRequest';
import { CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateByConditionResponse } from '../model/coreModelsResourceManagementScheduleTemplateGetScheduleTemplateByConditionResponse';
import { CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateItemByConditionRequest } from '../model/coreModelsResourceManagementScheduleTemplateGetScheduleTemplateItemByConditionRequest';
import { CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateItemByConditionResponse } from '../model/coreModelsResourceManagementScheduleTemplateGetScheduleTemplateItemByConditionResponse';
import { CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateSummaryRequest } from '../model/coreModelsResourceManagementScheduleTemplateGetScheduleTemplateSummaryRequest';
import { CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateSummaryResponse } from '../model/coreModelsResourceManagementScheduleTemplateGetScheduleTemplateSummaryResponse';
import { CoreModelsResourceManagementScheduleTemplateInitPageGetScheduleTemplateInitPageRequest } from '../model/coreModelsResourceManagementScheduleTemplateInitPageGetScheduleTemplateInitPageRequest';
import { CoreModelsResourceManagementScheduleTemplateInitPageGetScheduleTemplateInitPageResponse } from '../model/coreModelsResourceManagementScheduleTemplateInitPageGetScheduleTemplateInitPageResponse';
import { CoreModelsResourceManagementSendTestEmailSendTestEmailRequest } from '../model/coreModelsResourceManagementSendTestEmailSendTestEmailRequest';
import { CoreModelsResourceManagementSendTestEmailSendTestEmailResponse } from '../model/coreModelsResourceManagementSendTestEmailSendTestEmailResponse';
import { CoreModelsWebServiceBaseEndpointListResponse } from '../model/coreModelsWebServiceBaseEndpointListResponse';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ResourceManagementService {

    protected basePath = '/';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public auditLogGetAuditLogsByConditionPost(body?: CoreModelsResourceManagementAuditLogGetResourceManagementAuditLogsByConditionRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementAuditLogGetResourceManagementAuditLogsByConditionResponse>;
    public auditLogGetAuditLogsByConditionPost(body?: CoreModelsResourceManagementAuditLogGetResourceManagementAuditLogsByConditionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementAuditLogGetResourceManagementAuditLogsByConditionResponse>>;
    public auditLogGetAuditLogsByConditionPost(body?: CoreModelsResourceManagementAuditLogGetResourceManagementAuditLogsByConditionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementAuditLogGetResourceManagementAuditLogsByConditionResponse>>;
    public auditLogGetAuditLogsByConditionPost(body?: CoreModelsResourceManagementAuditLogGetResourceManagementAuditLogsByConditionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementAuditLogGetResourceManagementAuditLogsByConditionResponse>('post',`${this.basePath}/AuditLog/GetAuditLogsByCondition`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public holidayCreateOrUpdateHolidayPost(body?: CoreModelsResourceManagementHolidayCreateOrUpdateHolidayRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementHolidayCreateOrUpdateHolidayResponse>;
    public holidayCreateOrUpdateHolidayPost(body?: CoreModelsResourceManagementHolidayCreateOrUpdateHolidayRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementHolidayCreateOrUpdateHolidayResponse>>;
    public holidayCreateOrUpdateHolidayPost(body?: CoreModelsResourceManagementHolidayCreateOrUpdateHolidayRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementHolidayCreateOrUpdateHolidayResponse>>;
    public holidayCreateOrUpdateHolidayPost(body?: CoreModelsResourceManagementHolidayCreateOrUpdateHolidayRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementHolidayCreateOrUpdateHolidayResponse>('post',`${this.basePath}/Holiday/CreateOrUpdateHoliday`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public holidayDeleteHolidayDelete(body?: CoreModelsResourceManagementHolidayDeleteDeleteHolidayRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementHolidayDeleteDeleteHolidayResponse>;
    public holidayDeleteHolidayDelete(body?: CoreModelsResourceManagementHolidayDeleteDeleteHolidayRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementHolidayDeleteDeleteHolidayResponse>>;
    public holidayDeleteHolidayDelete(body?: CoreModelsResourceManagementHolidayDeleteDeleteHolidayRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementHolidayDeleteDeleteHolidayResponse>>;
    public holidayDeleteHolidayDelete(body?: CoreModelsResourceManagementHolidayDeleteDeleteHolidayRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementHolidayDeleteDeleteHolidayResponse>('delete',`${this.basePath}/Holiday/DeleteHoliday`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public holidayGetAllHolidaysByConditionPost(body?: CoreModelsResourceManagementHolidayGetAllHolidaysByConditionRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementHolidayGetAllHolidaysByConditionResponse>;
    public holidayGetAllHolidaysByConditionPost(body?: CoreModelsResourceManagementHolidayGetAllHolidaysByConditionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementHolidayGetAllHolidaysByConditionResponse>>;
    public holidayGetAllHolidaysByConditionPost(body?: CoreModelsResourceManagementHolidayGetAllHolidaysByConditionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementHolidayGetAllHolidaysByConditionResponse>>;
    public holidayGetAllHolidaysByConditionPost(body?: CoreModelsResourceManagementHolidayGetAllHolidaysByConditionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementHolidayGetAllHolidaysByConditionResponse>('post',`${this.basePath}/Holiday/GetAllHolidaysByCondition`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public holidayGetHolidaysFromAPIPost(body?: CoreModelsResourceManagementHolidayHolidayAPIHolidayAPIRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementHolidayHolidayAPIHolidayAPIResponse>;
    public holidayGetHolidaysFromAPIPost(body?: CoreModelsResourceManagementHolidayHolidayAPIHolidayAPIRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementHolidayHolidayAPIHolidayAPIResponse>>;
    public holidayGetHolidaysFromAPIPost(body?: CoreModelsResourceManagementHolidayHolidayAPIHolidayAPIRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementHolidayHolidayAPIHolidayAPIResponse>>;
    public holidayGetHolidaysFromAPIPost(body?: CoreModelsResourceManagementHolidayHolidayAPIHolidayAPIRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementHolidayHolidayAPIHolidayAPIResponse>('post',`${this.basePath}/Holiday/GetHolidaysFromAPI`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public initPageGetPlannedScheduleInitPagePost(body?: CoreModelsResourceManagementPlannedScheduleInitPageGetPlannedScheduleInitPageRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementPlannedScheduleInitPageGetPlannedScheduleInitPageResponse>;
    public initPageGetPlannedScheduleInitPagePost(body?: CoreModelsResourceManagementPlannedScheduleInitPageGetPlannedScheduleInitPageRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementPlannedScheduleInitPageGetPlannedScheduleInitPageResponse>>;
    public initPageGetPlannedScheduleInitPagePost(body?: CoreModelsResourceManagementPlannedScheduleInitPageGetPlannedScheduleInitPageRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementPlannedScheduleInitPageGetPlannedScheduleInitPageResponse>>;
    public initPageGetPlannedScheduleInitPagePost(body?: CoreModelsResourceManagementPlannedScheduleInitPageGetPlannedScheduleInitPageRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementPlannedScheduleInitPageGetPlannedScheduleInitPageResponse>('post',`${this.basePath}/InitPage/GetPlannedScheduleInitPage`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public initPageGetPlannedScheduleWarningInitPagePost(body?: CoreModelsResourceManagementPlannedScheduleWarningInitPageGetPlannedScheduleWarningInitPageRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementPlannedScheduleWarningInitPageGetPlannedScheduleWarningInitPageResponse>;
    public initPageGetPlannedScheduleWarningInitPagePost(body?: CoreModelsResourceManagementPlannedScheduleWarningInitPageGetPlannedScheduleWarningInitPageRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementPlannedScheduleWarningInitPageGetPlannedScheduleWarningInitPageResponse>>;
    public initPageGetPlannedScheduleWarningInitPagePost(body?: CoreModelsResourceManagementPlannedScheduleWarningInitPageGetPlannedScheduleWarningInitPageRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementPlannedScheduleWarningInitPageGetPlannedScheduleWarningInitPageResponse>>;
    public initPageGetPlannedScheduleWarningInitPagePost(body?: CoreModelsResourceManagementPlannedScheduleWarningInitPageGetPlannedScheduleWarningInitPageRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementPlannedScheduleWarningInitPageGetPlannedScheduleWarningInitPageResponse>('post',`${this.basePath}/InitPage/GetPlannedScheduleWarningInitPage`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public initPageGetPublishedScheduleInitPagePost(body?: CoreModelsResourceManagementPublishedScheduleInitPageGetPublishedScheduleInitPageRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementPublishedScheduleInitPageGetPublishedScheduleInitPageResponse>;
    public initPageGetPublishedScheduleInitPagePost(body?: CoreModelsResourceManagementPublishedScheduleInitPageGetPublishedScheduleInitPageRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementPublishedScheduleInitPageGetPublishedScheduleInitPageResponse>>;
    public initPageGetPublishedScheduleInitPagePost(body?: CoreModelsResourceManagementPublishedScheduleInitPageGetPublishedScheduleInitPageRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementPublishedScheduleInitPageGetPublishedScheduleInitPageResponse>>;
    public initPageGetPublishedScheduleInitPagePost(body?: CoreModelsResourceManagementPublishedScheduleInitPageGetPublishedScheduleInitPageRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementPublishedScheduleInitPageGetPublishedScheduleInitPageResponse>('post',`${this.basePath}/InitPage/GetPublishedScheduleInitPage`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public initPageGetPublishedScheduleWarningInitPagePost(body?: CoreModelsResourceManagementPublishedScheduleWarningInitPageGetPublishedScheduleWarningInitPageRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementPublishedScheduleWarningInitPageGetPublishedScheduleWarningInitPageResponse>;
    public initPageGetPublishedScheduleWarningInitPagePost(body?: CoreModelsResourceManagementPublishedScheduleWarningInitPageGetPublishedScheduleWarningInitPageRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementPublishedScheduleWarningInitPageGetPublishedScheduleWarningInitPageResponse>>;
    public initPageGetPublishedScheduleWarningInitPagePost(body?: CoreModelsResourceManagementPublishedScheduleWarningInitPageGetPublishedScheduleWarningInitPageRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementPublishedScheduleWarningInitPageGetPublishedScheduleWarningInitPageResponse>>;
    public initPageGetPublishedScheduleWarningInitPagePost(body?: CoreModelsResourceManagementPublishedScheduleWarningInitPageGetPublishedScheduleWarningInitPageRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementPublishedScheduleWarningInitPageGetPublishedScheduleWarningInitPageResponse>('post',`${this.basePath}/InitPage/GetPublishedScheduleWarningInitPage`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public initPageGetScheduleTemplateInitPagePost(body?: CoreModelsResourceManagementScheduleTemplateInitPageGetScheduleTemplateInitPageRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementScheduleTemplateInitPageGetScheduleTemplateInitPageResponse>;
    public initPageGetScheduleTemplateInitPagePost(body?: CoreModelsResourceManagementScheduleTemplateInitPageGetScheduleTemplateInitPageRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementScheduleTemplateInitPageGetScheduleTemplateInitPageResponse>>;
    public initPageGetScheduleTemplateInitPagePost(body?: CoreModelsResourceManagementScheduleTemplateInitPageGetScheduleTemplateInitPageRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementScheduleTemplateInitPageGetScheduleTemplateInitPageResponse>>;
    public initPageGetScheduleTemplateInitPagePost(body?: CoreModelsResourceManagementScheduleTemplateInitPageGetScheduleTemplateInitPageRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementScheduleTemplateInitPageGetScheduleTemplateInitPageResponse>('post',`${this.basePath}/InitPage/GetScheduleTemplateInitPage`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public plannedScheduleCreateOrUpdatePlannedSchedulePost(body?: CoreModelsResourceManagementPlannedScheduleCreateOrUpdatePlannedScheduleRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementPlannedScheduleCreateOrUpdatePlannedScheduleResponse>;
    public plannedScheduleCreateOrUpdatePlannedSchedulePost(body?: CoreModelsResourceManagementPlannedScheduleCreateOrUpdatePlannedScheduleRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementPlannedScheduleCreateOrUpdatePlannedScheduleResponse>>;
    public plannedScheduleCreateOrUpdatePlannedSchedulePost(body?: CoreModelsResourceManagementPlannedScheduleCreateOrUpdatePlannedScheduleRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementPlannedScheduleCreateOrUpdatePlannedScheduleResponse>>;
    public plannedScheduleCreateOrUpdatePlannedSchedulePost(body?: CoreModelsResourceManagementPlannedScheduleCreateOrUpdatePlannedScheduleRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementPlannedScheduleCreateOrUpdatePlannedScheduleResponse>('post',`${this.basePath}/PlannedSchedule/CreateOrUpdatePlannedSchedule`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public plannedScheduleDeletePlannedScheduleDelete(body?: CoreModelsResourceManagementPlannedScheduleDeleteDeletePlannedScheduleRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementPlannedScheduleDeleteDeletePlannedScheduleResponse>;
    public plannedScheduleDeletePlannedScheduleDelete(body?: CoreModelsResourceManagementPlannedScheduleDeleteDeletePlannedScheduleRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementPlannedScheduleDeleteDeletePlannedScheduleResponse>>;
    public plannedScheduleDeletePlannedScheduleDelete(body?: CoreModelsResourceManagementPlannedScheduleDeleteDeletePlannedScheduleRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementPlannedScheduleDeleteDeletePlannedScheduleResponse>>;
    public plannedScheduleDeletePlannedScheduleDelete(body?: CoreModelsResourceManagementPlannedScheduleDeleteDeletePlannedScheduleRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementPlannedScheduleDeleteDeletePlannedScheduleResponse>('delete',`${this.basePath}/PlannedSchedule/DeletePlannedSchedule`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public plannedScheduleGetPlannedScheduleByConditionPost(body?: CoreModelsResourceManagementPlannedScheduleGetPlannedScheduleByConditionRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementPlannedScheduleGetPlannedScheduleByConditionResponse>;
    public plannedScheduleGetPlannedScheduleByConditionPost(body?: CoreModelsResourceManagementPlannedScheduleGetPlannedScheduleByConditionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementPlannedScheduleGetPlannedScheduleByConditionResponse>>;
    public plannedScheduleGetPlannedScheduleByConditionPost(body?: CoreModelsResourceManagementPlannedScheduleGetPlannedScheduleByConditionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementPlannedScheduleGetPlannedScheduleByConditionResponse>>;
    public plannedScheduleGetPlannedScheduleByConditionPost(body?: CoreModelsResourceManagementPlannedScheduleGetPlannedScheduleByConditionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementPlannedScheduleGetPlannedScheduleByConditionResponse>('post',`${this.basePath}/PlannedSchedule/GetPlannedScheduleByCondition`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public plannedScheduleWarningCheckPlannedSchedulePost(body?: CoreModelsResourceManagementPlannedScheduleWarningCheckPlannedScheduleRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementPlannedScheduleWarningCheckPlannedScheduleResponse>;
    public plannedScheduleWarningCheckPlannedSchedulePost(body?: CoreModelsResourceManagementPlannedScheduleWarningCheckPlannedScheduleRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementPlannedScheduleWarningCheckPlannedScheduleResponse>>;
    public plannedScheduleWarningCheckPlannedSchedulePost(body?: CoreModelsResourceManagementPlannedScheduleWarningCheckPlannedScheduleRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementPlannedScheduleWarningCheckPlannedScheduleResponse>>;
    public plannedScheduleWarningCheckPlannedSchedulePost(body?: CoreModelsResourceManagementPlannedScheduleWarningCheckPlannedScheduleRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementPlannedScheduleWarningCheckPlannedScheduleResponse>('post',`${this.basePath}/PlannedScheduleWarning/CheckPlannedSchedule`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public plannedScheduleWarningDeletePlannedScheduleWarningDelete(body?: CoreModelsResourceManagementPlannedScheduleWarningDeleteDeletePlannedScheduleWarningRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementPlannedScheduleWarningDeleteDeletePlannedScheduleWarningResponse>;
    public plannedScheduleWarningDeletePlannedScheduleWarningDelete(body?: CoreModelsResourceManagementPlannedScheduleWarningDeleteDeletePlannedScheduleWarningRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementPlannedScheduleWarningDeleteDeletePlannedScheduleWarningResponse>>;
    public plannedScheduleWarningDeletePlannedScheduleWarningDelete(body?: CoreModelsResourceManagementPlannedScheduleWarningDeleteDeletePlannedScheduleWarningRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementPlannedScheduleWarningDeleteDeletePlannedScheduleWarningResponse>>;
    public plannedScheduleWarningDeletePlannedScheduleWarningDelete(body?: CoreModelsResourceManagementPlannedScheduleWarningDeleteDeletePlannedScheduleWarningRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementPlannedScheduleWarningDeleteDeletePlannedScheduleWarningResponse>('delete',`${this.basePath}/PlannedScheduleWarning/DeletePlannedScheduleWarning`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public plannedScheduleWarningGetPlannedScheduleWarningByConditionPost(body?: CoreModelsResourceManagementPlannedScheduleWarningGetPlannedScheduleWarningByConditionRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementPlannedScheduleWarningGetPlannedScheduleWarningByConditionResponse>;
    public plannedScheduleWarningGetPlannedScheduleWarningByConditionPost(body?: CoreModelsResourceManagementPlannedScheduleWarningGetPlannedScheduleWarningByConditionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementPlannedScheduleWarningGetPlannedScheduleWarningByConditionResponse>>;
    public plannedScheduleWarningGetPlannedScheduleWarningByConditionPost(body?: CoreModelsResourceManagementPlannedScheduleWarningGetPlannedScheduleWarningByConditionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementPlannedScheduleWarningGetPlannedScheduleWarningByConditionResponse>>;
    public plannedScheduleWarningGetPlannedScheduleWarningByConditionPost(body?: CoreModelsResourceManagementPlannedScheduleWarningGetPlannedScheduleWarningByConditionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementPlannedScheduleWarningGetPlannedScheduleWarningByConditionResponse>('post',`${this.basePath}/PlannedScheduleWarning/GetPlannedScheduleWarningByCondition`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public publishedScheduleCreateOrUpdatePublishedSchedulePost(body?: CoreModelsResourceManagementPublishedScheduleCreateOrUpdatePublishedScheduleRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementPublishedScheduleCreateOrUpdatePublishedScheduleResponse>;
    public publishedScheduleCreateOrUpdatePublishedSchedulePost(body?: CoreModelsResourceManagementPublishedScheduleCreateOrUpdatePublishedScheduleRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementPublishedScheduleCreateOrUpdatePublishedScheduleResponse>>;
    public publishedScheduleCreateOrUpdatePublishedSchedulePost(body?: CoreModelsResourceManagementPublishedScheduleCreateOrUpdatePublishedScheduleRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementPublishedScheduleCreateOrUpdatePublishedScheduleResponse>>;
    public publishedScheduleCreateOrUpdatePublishedSchedulePost(body?: CoreModelsResourceManagementPublishedScheduleCreateOrUpdatePublishedScheduleRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementPublishedScheduleCreateOrUpdatePublishedScheduleResponse>('post',`${this.basePath}/PublishedSchedule/CreateOrUpdatePublishedSchedule`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public publishedScheduleDeletePublishedScheduleDelete(body?: CoreModelsResourceManagementPublishedScheduleDeleteDeletePublishedScheduleRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementPublishedScheduleDeleteDeletePublishedScheduleResponse>;
    public publishedScheduleDeletePublishedScheduleDelete(body?: CoreModelsResourceManagementPublishedScheduleDeleteDeletePublishedScheduleRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementPublishedScheduleDeleteDeletePublishedScheduleResponse>>;
    public publishedScheduleDeletePublishedScheduleDelete(body?: CoreModelsResourceManagementPublishedScheduleDeleteDeletePublishedScheduleRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementPublishedScheduleDeleteDeletePublishedScheduleResponse>>;
    public publishedScheduleDeletePublishedScheduleDelete(body?: CoreModelsResourceManagementPublishedScheduleDeleteDeletePublishedScheduleRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementPublishedScheduleDeleteDeletePublishedScheduleResponse>('delete',`${this.basePath}/PublishedSchedule/DeletePublishedSchedule`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public publishedScheduleGetPublishedScheduleByConditionPost(body?: CoreModelsResourceManagementPublishedScheduleGetPublishedScheduleByConditionRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementPublishedScheduleGetPublishedScheduleByConditionResponse>;
    public publishedScheduleGetPublishedScheduleByConditionPost(body?: CoreModelsResourceManagementPublishedScheduleGetPublishedScheduleByConditionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementPublishedScheduleGetPublishedScheduleByConditionResponse>>;
    public publishedScheduleGetPublishedScheduleByConditionPost(body?: CoreModelsResourceManagementPublishedScheduleGetPublishedScheduleByConditionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementPublishedScheduleGetPublishedScheduleByConditionResponse>>;
    public publishedScheduleGetPublishedScheduleByConditionPost(body?: CoreModelsResourceManagementPublishedScheduleGetPublishedScheduleByConditionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementPublishedScheduleGetPublishedScheduleByConditionResponse>('post',`${this.basePath}/PublishedSchedule/GetPublishedScheduleByCondition`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public publishedScheduleWarningCheckPublishedSchedulePost(body?: CoreModelsResourceManagementPublishedScheduleWarningCheckPublishedScheduleRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementPublishedScheduleWarningCheckPublishedScheduleResponse>;
    public publishedScheduleWarningCheckPublishedSchedulePost(body?: CoreModelsResourceManagementPublishedScheduleWarningCheckPublishedScheduleRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementPublishedScheduleWarningCheckPublishedScheduleResponse>>;
    public publishedScheduleWarningCheckPublishedSchedulePost(body?: CoreModelsResourceManagementPublishedScheduleWarningCheckPublishedScheduleRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementPublishedScheduleWarningCheckPublishedScheduleResponse>>;
    public publishedScheduleWarningCheckPublishedSchedulePost(body?: CoreModelsResourceManagementPublishedScheduleWarningCheckPublishedScheduleRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementPublishedScheduleWarningCheckPublishedScheduleResponse>('post',`${this.basePath}/PublishedScheduleWarning/CheckPublishedSchedule`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public publishedScheduleWarningDeletePublishedScheduleWarningDelete(body?: CoreModelsResourceManagementPublishedScheduleWarningDeleteDeletePublishedScheduleWarningRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementPublishedScheduleWarningDeleteDeletePublishedScheduleWarningResponse>;
    public publishedScheduleWarningDeletePublishedScheduleWarningDelete(body?: CoreModelsResourceManagementPublishedScheduleWarningDeleteDeletePublishedScheduleWarningRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementPublishedScheduleWarningDeleteDeletePublishedScheduleWarningResponse>>;
    public publishedScheduleWarningDeletePublishedScheduleWarningDelete(body?: CoreModelsResourceManagementPublishedScheduleWarningDeleteDeletePublishedScheduleWarningRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementPublishedScheduleWarningDeleteDeletePublishedScheduleWarningResponse>>;
    public publishedScheduleWarningDeletePublishedScheduleWarningDelete(body?: CoreModelsResourceManagementPublishedScheduleWarningDeleteDeletePublishedScheduleWarningRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementPublishedScheduleWarningDeleteDeletePublishedScheduleWarningResponse>('delete',`${this.basePath}/PublishedScheduleWarning/DeletePublishedScheduleWarning`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public publishedScheduleWarningGetPublishedScheduleWarningByConditionPost(body?: CoreModelsResourceManagementPublishedScheduleWarningGetPublishedScheduleWarningByConditionRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementPublishedScheduleWarningGetPublishedScheduleWarningByConditionResponse>;
    public publishedScheduleWarningGetPublishedScheduleWarningByConditionPost(body?: CoreModelsResourceManagementPublishedScheduleWarningGetPublishedScheduleWarningByConditionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementPublishedScheduleWarningGetPublishedScheduleWarningByConditionResponse>>;
    public publishedScheduleWarningGetPublishedScheduleWarningByConditionPost(body?: CoreModelsResourceManagementPublishedScheduleWarningGetPublishedScheduleWarningByConditionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementPublishedScheduleWarningGetPublishedScheduleWarningByConditionResponse>>;
    public publishedScheduleWarningGetPublishedScheduleWarningByConditionPost(body?: CoreModelsResourceManagementPublishedScheduleWarningGetPublishedScheduleWarningByConditionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementPublishedScheduleWarningGetPublishedScheduleWarningByConditionResponse>('post',`${this.basePath}/PublishedScheduleWarning/GetPublishedScheduleWarningByCondition`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public publishingCreatePublishingPost(body?: CoreModelsResourceManagementPublishedSchedulePublishingCreatePublishingRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementPublishedSchedulePublishingCreatePublishingResponse>;
    public publishingCreatePublishingPost(body?: CoreModelsResourceManagementPublishedSchedulePublishingCreatePublishingRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementPublishedSchedulePublishingCreatePublishingResponse>>;
    public publishingCreatePublishingPost(body?: CoreModelsResourceManagementPublishedSchedulePublishingCreatePublishingRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementPublishedSchedulePublishingCreatePublishingResponse>>;
    public publishingCreatePublishingPost(body?: CoreModelsResourceManagementPublishedSchedulePublishingCreatePublishingRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementPublishedSchedulePublishingCreatePublishingResponse>('post',`${this.basePath}/Publishing/CreatePublishing`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param T 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public resourceManagementGetEnumGet(T?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<any>>;
    public resourceManagementGetEnumGet(T?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<any>>>;
    public resourceManagementGetEnumGet(T?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<any>>>;
    public resourceManagementGetEnumGet(T?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (T !== undefined && T !== null) {
            queryParameters = queryParameters.set('T', <any>T);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<any>>('get',`${this.basePath}/ResourceManagement/GetEnum`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public resourceManagementPingGet(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public resourceManagementPingGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public resourceManagementPingGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public resourceManagementPingGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('get',`${this.basePath}/ResourceManagement/Ping`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public scheduleEmployeeSubstitutionGetEmployeesForSubstitutionPost(body?: CoreModelsResourceManagementScheduleSubstituteEmployeesGetEmployeesForSubstitutionRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementScheduleSubstituteEmployeesGetEmployeesForSubstitutionResponse>;
    public scheduleEmployeeSubstitutionGetEmployeesForSubstitutionPost(body?: CoreModelsResourceManagementScheduleSubstituteEmployeesGetEmployeesForSubstitutionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementScheduleSubstituteEmployeesGetEmployeesForSubstitutionResponse>>;
    public scheduleEmployeeSubstitutionGetEmployeesForSubstitutionPost(body?: CoreModelsResourceManagementScheduleSubstituteEmployeesGetEmployeesForSubstitutionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementScheduleSubstituteEmployeesGetEmployeesForSubstitutionResponse>>;
    public scheduleEmployeeSubstitutionGetEmployeesForSubstitutionPost(body?: CoreModelsResourceManagementScheduleSubstituteEmployeesGetEmployeesForSubstitutionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementScheduleSubstituteEmployeesGetEmployeesForSubstitutionResponse>('post',`${this.basePath}/ScheduleEmployeeSubstitution/GetEmployeesForSubstitution`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public scheduleEmployeeSubstitutionSubstituteEmployeesPost(body?: CoreModelsResourceManagementScheduleSubstituteEmployeesSubstituteEmployeesRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementScheduleSubstituteEmployeesSubstituteEmployeesResponse>;
    public scheduleEmployeeSubstitutionSubstituteEmployeesPost(body?: CoreModelsResourceManagementScheduleSubstituteEmployeesSubstituteEmployeesRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementScheduleSubstituteEmployeesSubstituteEmployeesResponse>>;
    public scheduleEmployeeSubstitutionSubstituteEmployeesPost(body?: CoreModelsResourceManagementScheduleSubstituteEmployeesSubstituteEmployeesRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementScheduleSubstituteEmployeesSubstituteEmployeesResponse>>;
    public scheduleEmployeeSubstitutionSubstituteEmployeesPost(body?: CoreModelsResourceManagementScheduleSubstituteEmployeesSubstituteEmployeesRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementScheduleSubstituteEmployeesSubstituteEmployeesResponse>('post',`${this.basePath}/ScheduleEmployeeSubstitution/SubstituteEmployees`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public scheduleGeneratorGeneratePlannedSchedulePost(body?: CoreModelsResourceManagementScheduleGeneratorGeneratePlannedScheduleRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementScheduleGeneratorGeneratePlannedScheduleResponse>;
    public scheduleGeneratorGeneratePlannedSchedulePost(body?: CoreModelsResourceManagementScheduleGeneratorGeneratePlannedScheduleRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementScheduleGeneratorGeneratePlannedScheduleResponse>>;
    public scheduleGeneratorGeneratePlannedSchedulePost(body?: CoreModelsResourceManagementScheduleGeneratorGeneratePlannedScheduleRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementScheduleGeneratorGeneratePlannedScheduleResponse>>;
    public scheduleGeneratorGeneratePlannedSchedulePost(body?: CoreModelsResourceManagementScheduleGeneratorGeneratePlannedScheduleRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementScheduleGeneratorGeneratePlannedScheduleResponse>('post',`${this.basePath}/ScheduleGenerator/GeneratePlannedSchedule`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public scheduleTemplateCreateOrUpdateScheduleTemplateItemPost(body?: CoreModelsResourceManagementScheduleTemplateCreateOrUpdateScheduleTemplateItemRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementScheduleTemplateCreateOrUpdateScheduleTemplateItemResponse>;
    public scheduleTemplateCreateOrUpdateScheduleTemplateItemPost(body?: CoreModelsResourceManagementScheduleTemplateCreateOrUpdateScheduleTemplateItemRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementScheduleTemplateCreateOrUpdateScheduleTemplateItemResponse>>;
    public scheduleTemplateCreateOrUpdateScheduleTemplateItemPost(body?: CoreModelsResourceManagementScheduleTemplateCreateOrUpdateScheduleTemplateItemRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementScheduleTemplateCreateOrUpdateScheduleTemplateItemResponse>>;
    public scheduleTemplateCreateOrUpdateScheduleTemplateItemPost(body?: CoreModelsResourceManagementScheduleTemplateCreateOrUpdateScheduleTemplateItemRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementScheduleTemplateCreateOrUpdateScheduleTemplateItemResponse>('post',`${this.basePath}/ScheduleTemplate/CreateOrUpdateScheduleTemplateItem`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public scheduleTemplateCreateOrUpdateScheduleTemplatePost(body?: CoreModelsResourceManagementScheduleTemplateCreateOrUpdateScheduleTemplateRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementScheduleTemplateCreateOrUpdateScheduleTemplateResponse>;
    public scheduleTemplateCreateOrUpdateScheduleTemplatePost(body?: CoreModelsResourceManagementScheduleTemplateCreateOrUpdateScheduleTemplateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementScheduleTemplateCreateOrUpdateScheduleTemplateResponse>>;
    public scheduleTemplateCreateOrUpdateScheduleTemplatePost(body?: CoreModelsResourceManagementScheduleTemplateCreateOrUpdateScheduleTemplateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementScheduleTemplateCreateOrUpdateScheduleTemplateResponse>>;
    public scheduleTemplateCreateOrUpdateScheduleTemplatePost(body?: CoreModelsResourceManagementScheduleTemplateCreateOrUpdateScheduleTemplateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementScheduleTemplateCreateOrUpdateScheduleTemplateResponse>('post',`${this.basePath}/ScheduleTemplate/CreateOrUpdateScheduleTemplate`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public scheduleTemplateCreateScheduleFromTemplatePost(body?: CoreModelsResourceManagementScheduleTemplateCreateScheduleFromTemplateRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementScheduleTemplateCreateScheduleFromTemplateResponse>;
    public scheduleTemplateCreateScheduleFromTemplatePost(body?: CoreModelsResourceManagementScheduleTemplateCreateScheduleFromTemplateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementScheduleTemplateCreateScheduleFromTemplateResponse>>;
    public scheduleTemplateCreateScheduleFromTemplatePost(body?: CoreModelsResourceManagementScheduleTemplateCreateScheduleFromTemplateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementScheduleTemplateCreateScheduleFromTemplateResponse>>;
    public scheduleTemplateCreateScheduleFromTemplatePost(body?: CoreModelsResourceManagementScheduleTemplateCreateScheduleFromTemplateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementScheduleTemplateCreateScheduleFromTemplateResponse>('post',`${this.basePath}/ScheduleTemplate/CreateScheduleFromTemplate`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public scheduleTemplateCreateTemplateFromPublishedSchedulePost(body?: CoreModelsResourceManagementScheduleTemplateCreateTemplateFromPublishedScheduleRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementScheduleTemplateCreateTemplateFromPublishedScheduleResponse>;
    public scheduleTemplateCreateTemplateFromPublishedSchedulePost(body?: CoreModelsResourceManagementScheduleTemplateCreateTemplateFromPublishedScheduleRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementScheduleTemplateCreateTemplateFromPublishedScheduleResponse>>;
    public scheduleTemplateCreateTemplateFromPublishedSchedulePost(body?: CoreModelsResourceManagementScheduleTemplateCreateTemplateFromPublishedScheduleRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementScheduleTemplateCreateTemplateFromPublishedScheduleResponse>>;
    public scheduleTemplateCreateTemplateFromPublishedSchedulePost(body?: CoreModelsResourceManagementScheduleTemplateCreateTemplateFromPublishedScheduleRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementScheduleTemplateCreateTemplateFromPublishedScheduleResponse>('post',`${this.basePath}/ScheduleTemplate/CreateTemplateFromPublishedSchedule`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public scheduleTemplateDeleteScheduleTemplateDelete(body?: CoreModelsResourceManagementScheduleTemplateDeleteDeleteScheduleTemplateRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementScheduleTemplateDeleteDeleteScheduleTemplateResponse>;
    public scheduleTemplateDeleteScheduleTemplateDelete(body?: CoreModelsResourceManagementScheduleTemplateDeleteDeleteScheduleTemplateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementScheduleTemplateDeleteDeleteScheduleTemplateResponse>>;
    public scheduleTemplateDeleteScheduleTemplateDelete(body?: CoreModelsResourceManagementScheduleTemplateDeleteDeleteScheduleTemplateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementScheduleTemplateDeleteDeleteScheduleTemplateResponse>>;
    public scheduleTemplateDeleteScheduleTemplateDelete(body?: CoreModelsResourceManagementScheduleTemplateDeleteDeleteScheduleTemplateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementScheduleTemplateDeleteDeleteScheduleTemplateResponse>('delete',`${this.basePath}/ScheduleTemplate/DeleteScheduleTemplate`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public scheduleTemplateDeleteScheduleTemplateItemDelete(body?: CoreModelsResourceManagementScheduleTemplateDeleteDeleteScheduleTemplateItemRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementScheduleTemplateDeleteDeleteScheduleTemplateItemResponse>;
    public scheduleTemplateDeleteScheduleTemplateItemDelete(body?: CoreModelsResourceManagementScheduleTemplateDeleteDeleteScheduleTemplateItemRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementScheduleTemplateDeleteDeleteScheduleTemplateItemResponse>>;
    public scheduleTemplateDeleteScheduleTemplateItemDelete(body?: CoreModelsResourceManagementScheduleTemplateDeleteDeleteScheduleTemplateItemRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementScheduleTemplateDeleteDeleteScheduleTemplateItemResponse>>;
    public scheduleTemplateDeleteScheduleTemplateItemDelete(body?: CoreModelsResourceManagementScheduleTemplateDeleteDeleteScheduleTemplateItemRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementScheduleTemplateDeleteDeleteScheduleTemplateItemResponse>('delete',`${this.basePath}/ScheduleTemplate/DeleteScheduleTemplateItem`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public scheduleTemplateGetScheduleTemplateByConditionPost(body?: CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateByConditionRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateByConditionResponse>;
    public scheduleTemplateGetScheduleTemplateByConditionPost(body?: CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateByConditionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateByConditionResponse>>;
    public scheduleTemplateGetScheduleTemplateByConditionPost(body?: CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateByConditionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateByConditionResponse>>;
    public scheduleTemplateGetScheduleTemplateByConditionPost(body?: CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateByConditionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateByConditionResponse>('post',`${this.basePath}/ScheduleTemplate/GetScheduleTemplateByCondition`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public scheduleTemplateGetScheduleTemplateItemByConditionPost(body?: CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateItemByConditionRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateItemByConditionResponse>;
    public scheduleTemplateGetScheduleTemplateItemByConditionPost(body?: CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateItemByConditionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateItemByConditionResponse>>;
    public scheduleTemplateGetScheduleTemplateItemByConditionPost(body?: CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateItemByConditionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateItemByConditionResponse>>;
    public scheduleTemplateGetScheduleTemplateItemByConditionPost(body?: CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateItemByConditionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateItemByConditionResponse>('post',`${this.basePath}/ScheduleTemplate/GetScheduleTemplateItemByCondition`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public scheduleTemplateGetScheduleTemplateSummaryPost(body?: CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateSummaryRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateSummaryResponse>;
    public scheduleTemplateGetScheduleTemplateSummaryPost(body?: CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateSummaryRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateSummaryResponse>>;
    public scheduleTemplateGetScheduleTemplateSummaryPost(body?: CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateSummaryRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateSummaryResponse>>;
    public scheduleTemplateGetScheduleTemplateSummaryPost(body?: CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateSummaryRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementScheduleTemplateGetScheduleTemplateSummaryResponse>('post',`${this.basePath}/ScheduleTemplate/GetScheduleTemplateSummary`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public sendEmailSendTestEmailPost(body?: CoreModelsResourceManagementSendTestEmailSendTestEmailRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsResourceManagementSendTestEmailSendTestEmailResponse>;
    public sendEmailSendTestEmailPost(body?: CoreModelsResourceManagementSendTestEmailSendTestEmailRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsResourceManagementSendTestEmailSendTestEmailResponse>>;
    public sendEmailSendTestEmailPost(body?: CoreModelsResourceManagementSendTestEmailSendTestEmailRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsResourceManagementSendTestEmailSendTestEmailResponse>>;
    public sendEmailSendTestEmailPost(body?: CoreModelsResourceManagementSendTestEmailSendTestEmailRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsResourceManagementSendTestEmailSendTestEmailResponse>('post',`${this.basePath}/SendEmail/SendTestEmail`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webServiceInfoGetEndpointListGet(observe?: 'body', reportProgress?: boolean): Observable<Array<CoreModelsWebServiceBaseEndpointListResponse>>;
    public webServiceInfoGetEndpointListGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CoreModelsWebServiceBaseEndpointListResponse>>>;
    public webServiceInfoGetEndpointListGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CoreModelsWebServiceBaseEndpointListResponse>>>;
    public webServiceInfoGetEndpointListGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<CoreModelsWebServiceBaseEndpointListResponse>>('get',`${this.basePath}/WebServiceInfo/GetEndpointList`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
