/**
 * AuthenticationWebService
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { CoreModelsAuthenticationAdminExportAuthenticationEndpointsRequest } from '../model/coreModelsAuthenticationAdminExportAuthenticationEndpointsRequest';
import { CoreModelsAuthenticationAuditLogGetSecAuditLogsByConditionRequest } from '../model/coreModelsAuthenticationAuditLogGetSecAuditLogsByConditionRequest';
import { CoreModelsAuthenticationAuditLogGetSecAuditLogsByConditionResponse } from '../model/coreModelsAuthenticationAuditLogGetSecAuditLogsByConditionResponse';
import { CoreModelsAuthenticationAuthenticationAuthenticationRequest } from '../model/coreModelsAuthenticationAuthenticationAuthenticationRequest';
import { CoreModelsAuthenticationAuthenticationAuthenticationResponse } from '../model/coreModelsAuthenticationAuthenticationAuthenticationResponse';
import { CoreModelsAuthenticationFunctionCreateOrUpdateFunctionRequest } from '../model/coreModelsAuthenticationFunctionCreateOrUpdateFunctionRequest';
import { CoreModelsAuthenticationFunctionCreateOrUpdateFunctionResponse } from '../model/coreModelsAuthenticationFunctionCreateOrUpdateFunctionResponse';
import { CoreModelsAuthenticationFunctionDeleteDeleteFunctionRequest } from '../model/coreModelsAuthenticationFunctionDeleteDeleteFunctionRequest';
import { CoreModelsAuthenticationFunctionDeleteDeleteFunctionResponse } from '../model/coreModelsAuthenticationFunctionDeleteDeleteFunctionResponse';
import { CoreModelsAuthenticationFunctionGetFunctionByConditionRequest } from '../model/coreModelsAuthenticationFunctionGetFunctionByConditionRequest';
import { CoreModelsAuthenticationFunctionGetFunctionByConditionResponse } from '../model/coreModelsAuthenticationFunctionGetFunctionByConditionResponse';
import { CoreModelsAuthenticationFunctionInitPageFunctionInitPageRequest } from '../model/coreModelsAuthenticationFunctionInitPageFunctionInitPageRequest';
import { CoreModelsAuthenticationFunctionInitPageFunctionInitPageResponse } from '../model/coreModelsAuthenticationFunctionInitPageFunctionInitPageResponse';
import { CoreModelsAuthenticationGoogleAuthenticatorDeleteDeleteGoogleAuthenticatorTokenRequest } from '../model/coreModelsAuthenticationGoogleAuthenticatorDeleteDeleteGoogleAuthenticatorTokenRequest';
import { CoreModelsAuthenticationGoogleAuthenticatorDeleteDeleteGoogleAuthenticatorTokenResponse } from '../model/coreModelsAuthenticationGoogleAuthenticatorDeleteDeleteGoogleAuthenticatorTokenResponse';
import { CoreModelsAuthenticationGoogleAuthenticatorGoogleAuthenticatorCreateTokenRequest } from '../model/coreModelsAuthenticationGoogleAuthenticatorGoogleAuthenticatorCreateTokenRequest';
import { CoreModelsAuthenticationGoogleAuthenticatorGoogleAuthenticatorCreateTokenResponse } from '../model/coreModelsAuthenticationGoogleAuthenticatorGoogleAuthenticatorCreateTokenResponse';
import { CoreModelsAuthenticationGoogleAuthenticatorGoogleAuthenticatorRequest } from '../model/coreModelsAuthenticationGoogleAuthenticatorGoogleAuthenticatorRequest';
import { CoreModelsAuthenticationGoogleAuthenticatorGoogleAuthenticatorResponse } from '../model/coreModelsAuthenticationGoogleAuthenticatorGoogleAuthenticatorResponse';
import { CoreModelsAuthenticationPasswordPasswordChangeRequest } from '../model/coreModelsAuthenticationPasswordPasswordChangeRequest';
import { CoreModelsAuthenticationPasswordPasswordChangeResponse } from '../model/coreModelsAuthenticationPasswordPasswordChangeResponse';
import { CoreModelsAuthenticationPasswordResetPasswordRequest } from '../model/coreModelsAuthenticationPasswordResetPasswordRequest';
import { CoreModelsAuthenticationPasswordResetPasswordResponse } from '../model/coreModelsAuthenticationPasswordResetPasswordResponse';
import { CoreModelsAuthenticationPasswordSetPasswordRequest } from '../model/coreModelsAuthenticationPasswordSetPasswordRequest';
import { CoreModelsAuthenticationPasswordSetPasswordResponse } from '../model/coreModelsAuthenticationPasswordSetPasswordResponse';
import { CoreModelsAuthenticationPasswordSetPasswordToDefaultRequest } from '../model/coreModelsAuthenticationPasswordSetPasswordToDefaultRequest';
import { CoreModelsAuthenticationPasswordSetPasswordToDefaultResponse } from '../model/coreModelsAuthenticationPasswordSetPasswordToDefaultResponse';
import { CoreModelsAuthenticationRightCreateOrUpdateRightRequest } from '../model/coreModelsAuthenticationRightCreateOrUpdateRightRequest';
import { CoreModelsAuthenticationRightCreateOrUpdateRightResponse } from '../model/coreModelsAuthenticationRightCreateOrUpdateRightResponse';
import { CoreModelsAuthenticationRightDeleteDeleteRightRequest } from '../model/coreModelsAuthenticationRightDeleteDeleteRightRequest';
import { CoreModelsAuthenticationRightDeleteDeleteRightResponse } from '../model/coreModelsAuthenticationRightDeleteDeleteRightResponse';
import { CoreModelsAuthenticationRightGetRightByConditionRequest } from '../model/coreModelsAuthenticationRightGetRightByConditionRequest';
import { CoreModelsAuthenticationRightGetRightByConditionResponse } from '../model/coreModelsAuthenticationRightGetRightByConditionResponse';
import { CoreModelsAuthenticationRoleCreateOrUpdateRoleRequest } from '../model/coreModelsAuthenticationRoleCreateOrUpdateRoleRequest';
import { CoreModelsAuthenticationRoleCreateOrUpdateRoleResponse } from '../model/coreModelsAuthenticationRoleCreateOrUpdateRoleResponse';
import { CoreModelsAuthenticationRoleDeleteDeleteRoleRequest } from '../model/coreModelsAuthenticationRoleDeleteDeleteRoleRequest';
import { CoreModelsAuthenticationRoleDeleteDeleteRoleResponse } from '../model/coreModelsAuthenticationRoleDeleteDeleteRoleResponse';
import { CoreModelsAuthenticationRoleGetRoleByConditionRequest } from '../model/coreModelsAuthenticationRoleGetRoleByConditionRequest';
import { CoreModelsAuthenticationRoleGetRoleByConditionResponse } from '../model/coreModelsAuthenticationRoleGetRoleByConditionResponse';
import { CoreModelsAuthenticationRoleXRightCreateOrUpdateRoleXRightRequest } from '../model/coreModelsAuthenticationRoleXRightCreateOrUpdateRoleXRightRequest';
import { CoreModelsAuthenticationRoleXRightCreateOrUpdateRoleXRightResponse } from '../model/coreModelsAuthenticationRoleXRightCreateOrUpdateRoleXRightResponse';
import { CoreModelsAuthenticationRoleXRightDeleteDeleteRoleXRightRequest } from '../model/coreModelsAuthenticationRoleXRightDeleteDeleteRoleXRightRequest';
import { CoreModelsAuthenticationRoleXRightDeleteDeleteRoleXRightResponse } from '../model/coreModelsAuthenticationRoleXRightDeleteDeleteRoleXRightResponse';
import { CoreModelsAuthenticationSwissUserXRoleCreateOrUpdateSwissUserXRoleRequest } from '../model/coreModelsAuthenticationSwissUserXRoleCreateOrUpdateSwissUserXRoleRequest';
import { CoreModelsAuthenticationSwissUserXRoleCreateOrUpdateSwissUserXRoleResponse } from '../model/coreModelsAuthenticationSwissUserXRoleCreateOrUpdateSwissUserXRoleResponse';
import { CoreModelsAuthenticationSwissUserXRoleDeleteSwissUserXRoleRequest } from '../model/coreModelsAuthenticationSwissUserXRoleDeleteSwissUserXRoleRequest';
import { CoreModelsAuthenticationSwissUserXRoleDeleteSwissUserXRoleResponse } from '../model/coreModelsAuthenticationSwissUserXRoleDeleteSwissUserXRoleResponse';
import { CoreModelsAuthenticationSwissUserXRoleGetClinicsByUserIdReponse } from '../model/coreModelsAuthenticationSwissUserXRoleGetClinicsByUserIdReponse';
import { CoreModelsAuthenticationSwissUserXRoleGetClinicsByUserIdRequest } from '../model/coreModelsAuthenticationSwissUserXRoleGetClinicsByUserIdRequest';
import { CoreModelsAuthenticationSwissUserXRoleGetSwissUserXRoleByConditionRequest } from '../model/coreModelsAuthenticationSwissUserXRoleGetSwissUserXRoleByConditionRequest';
import { CoreModelsAuthenticationSwissUserXRoleGetSwissUserXRoleByConditionResponse } from '../model/coreModelsAuthenticationSwissUserXRoleGetSwissUserXRoleByConditionResponse';
import { CoreModelsAuthenticationUserCreateOrUpdateSwissUserRequest } from '../model/coreModelsAuthenticationUserCreateOrUpdateSwissUserRequest';
import { CoreModelsAuthenticationUserCreateOrUpdateSwissUserResponse } from '../model/coreModelsAuthenticationUserCreateOrUpdateSwissUserResponse';
import { CoreModelsAuthenticationUserCreateOrUpdateSwissUserWithPasswordRequest } from '../model/coreModelsAuthenticationUserCreateOrUpdateSwissUserWithPasswordRequest';
import { CoreModelsAuthenticationUserCreateOrUpdateSwissUserWithPasswordResponse } from '../model/coreModelsAuthenticationUserCreateOrUpdateSwissUserWithPasswordResponse';
import { CoreModelsAuthenticationUserDeleteDeleteUserRequest } from '../model/coreModelsAuthenticationUserDeleteDeleteUserRequest';
import { CoreModelsAuthenticationUserDeleteDeleteUserResponse } from '../model/coreModelsAuthenticationUserDeleteDeleteUserResponse';
import { CoreModelsAuthenticationUserGetSwissUserByConditionRequest } from '../model/coreModelsAuthenticationUserGetSwissUserByConditionRequest';
import { CoreModelsAuthenticationUserGetSwissUserByConditionResponse } from '../model/coreModelsAuthenticationUserGetSwissUserByConditionResponse';
import { CoreModelsAuthenticationUserInitPageGetSwissUserInitPageRequest } from '../model/coreModelsAuthenticationUserInitPageGetSwissUserInitPageRequest';
import { CoreModelsAuthenticationUserInitPageGetSwissUserInitPageResponse } from '../model/coreModelsAuthenticationUserInitPageGetSwissUserInitPageResponse';
import { CoreModelsAuthenticationUserUserIDCheckExistsRequest } from '../model/coreModelsAuthenticationUserUserIDCheckExistsRequest';
import { CoreModelsAuthenticationUserUserIDCheckExistsResponse } from '../model/coreModelsAuthenticationUserUserIDCheckExistsResponse';
import { CoreModelsDTOsAdminExportEndpointsResponse } from '../model/coreModelsDTOsAdminExportEndpointsResponse';
import { CoreModelsWebServiceBaseEndpointListResponse } from '../model/coreModelsWebServiceBaseEndpointListResponse';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class AuthenticationWebServiceService {

    protected basePath = '/';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public adminExportAuthenticationEndpointsPost(body?: CoreModelsAuthenticationAdminExportAuthenticationEndpointsRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsDTOsAdminExportEndpointsResponse>;
    public adminExportAuthenticationEndpointsPost(body?: CoreModelsAuthenticationAdminExportAuthenticationEndpointsRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsDTOsAdminExportEndpointsResponse>>;
    public adminExportAuthenticationEndpointsPost(body?: CoreModelsAuthenticationAdminExportAuthenticationEndpointsRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsDTOsAdminExportEndpointsResponse>>;
    public adminExportAuthenticationEndpointsPost(body?: CoreModelsAuthenticationAdminExportAuthenticationEndpointsRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsDTOsAdminExportEndpointsResponse>('post',`${this.basePath}/Admin/ExportAuthenticationEndpoints`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public authenticationAuthenticateByGoogleAuthenticatorPost(body?: CoreModelsAuthenticationGoogleAuthenticatorGoogleAuthenticatorRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationGoogleAuthenticatorGoogleAuthenticatorResponse>;
    public authenticationAuthenticateByGoogleAuthenticatorPost(body?: CoreModelsAuthenticationGoogleAuthenticatorGoogleAuthenticatorRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationGoogleAuthenticatorGoogleAuthenticatorResponse>>;
    public authenticationAuthenticateByGoogleAuthenticatorPost(body?: CoreModelsAuthenticationGoogleAuthenticatorGoogleAuthenticatorRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationGoogleAuthenticatorGoogleAuthenticatorResponse>>;
    public authenticationAuthenticateByGoogleAuthenticatorPost(body?: CoreModelsAuthenticationGoogleAuthenticatorGoogleAuthenticatorRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationGoogleAuthenticatorGoogleAuthenticatorResponse>('post',`${this.basePath}/Authentication/AuthenticateByGoogleAuthenticator`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public authenticationAuthenticatePost(body?: CoreModelsAuthenticationAuthenticationAuthenticationRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationAuthenticationAuthenticationResponse>;
    public authenticationAuthenticatePost(body?: CoreModelsAuthenticationAuthenticationAuthenticationRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationAuthenticationAuthenticationResponse>>;
    public authenticationAuthenticatePost(body?: CoreModelsAuthenticationAuthenticationAuthenticationRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationAuthenticationAuthenticationResponse>>;
    public authenticationAuthenticatePost(body?: CoreModelsAuthenticationAuthenticationAuthenticationRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationAuthenticationAuthenticationResponse>('post',`${this.basePath}/Authentication/Authenticate`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param T 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public authenticationWebServiceGetEnumGet(T?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<any>>;
    public authenticationWebServiceGetEnumGet(T?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<any>>>;
    public authenticationWebServiceGetEnumGet(T?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<any>>>;
    public authenticationWebServiceGetEnumGet(T?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (T !== undefined && T !== null) {
            queryParameters = queryParameters.set('T', <any>T);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<any>>('get',`${this.basePath}/AuthenticationWebService/GetEnum`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public authenticationWebServicePingGet(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public authenticationWebServicePingGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public authenticationWebServicePingGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public authenticationWebServicePingGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('get',`${this.basePath}/AuthenticationWebService/Ping`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public functionCreateOrUpdateFunctionPost(body?: CoreModelsAuthenticationFunctionCreateOrUpdateFunctionRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationFunctionCreateOrUpdateFunctionResponse>;
    public functionCreateOrUpdateFunctionPost(body?: CoreModelsAuthenticationFunctionCreateOrUpdateFunctionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationFunctionCreateOrUpdateFunctionResponse>>;
    public functionCreateOrUpdateFunctionPost(body?: CoreModelsAuthenticationFunctionCreateOrUpdateFunctionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationFunctionCreateOrUpdateFunctionResponse>>;
    public functionCreateOrUpdateFunctionPost(body?: CoreModelsAuthenticationFunctionCreateOrUpdateFunctionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationFunctionCreateOrUpdateFunctionResponse>('post',`${this.basePath}/Function/CreateOrUpdateFunction`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public functionGetFunctionByConditionPost(body?: CoreModelsAuthenticationFunctionGetFunctionByConditionRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationFunctionGetFunctionByConditionResponse>;
    public functionGetFunctionByConditionPost(body?: CoreModelsAuthenticationFunctionGetFunctionByConditionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationFunctionGetFunctionByConditionResponse>>;
    public functionGetFunctionByConditionPost(body?: CoreModelsAuthenticationFunctionGetFunctionByConditionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationFunctionGetFunctionByConditionResponse>>;
    public functionGetFunctionByConditionPost(body?: CoreModelsAuthenticationFunctionGetFunctionByConditionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationFunctionGetFunctionByConditionResponse>('post',`${this.basePath}/Function/GetFunctionByCondition`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public googleAuthenticatorCreateGoogleAuthenticatorTokenPost(body?: CoreModelsAuthenticationGoogleAuthenticatorGoogleAuthenticatorCreateTokenRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationGoogleAuthenticatorGoogleAuthenticatorCreateTokenResponse>;
    public googleAuthenticatorCreateGoogleAuthenticatorTokenPost(body?: CoreModelsAuthenticationGoogleAuthenticatorGoogleAuthenticatorCreateTokenRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationGoogleAuthenticatorGoogleAuthenticatorCreateTokenResponse>>;
    public googleAuthenticatorCreateGoogleAuthenticatorTokenPost(body?: CoreModelsAuthenticationGoogleAuthenticatorGoogleAuthenticatorCreateTokenRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationGoogleAuthenticatorGoogleAuthenticatorCreateTokenResponse>>;
    public googleAuthenticatorCreateGoogleAuthenticatorTokenPost(body?: CoreModelsAuthenticationGoogleAuthenticatorGoogleAuthenticatorCreateTokenRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationGoogleAuthenticatorGoogleAuthenticatorCreateTokenResponse>('post',`${this.basePath}/GoogleAuthenticator/CreateGoogleAuthenticatorToken`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public googleAuthenticatorDeleteGoogleAuthenticatorTokenDelete(body?: CoreModelsAuthenticationGoogleAuthenticatorDeleteDeleteGoogleAuthenticatorTokenRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationGoogleAuthenticatorDeleteDeleteGoogleAuthenticatorTokenResponse>;
    public googleAuthenticatorDeleteGoogleAuthenticatorTokenDelete(body?: CoreModelsAuthenticationGoogleAuthenticatorDeleteDeleteGoogleAuthenticatorTokenRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationGoogleAuthenticatorDeleteDeleteGoogleAuthenticatorTokenResponse>>;
    public googleAuthenticatorDeleteGoogleAuthenticatorTokenDelete(body?: CoreModelsAuthenticationGoogleAuthenticatorDeleteDeleteGoogleAuthenticatorTokenRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationGoogleAuthenticatorDeleteDeleteGoogleAuthenticatorTokenResponse>>;
    public googleAuthenticatorDeleteGoogleAuthenticatorTokenDelete(body?: CoreModelsAuthenticationGoogleAuthenticatorDeleteDeleteGoogleAuthenticatorTokenRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationGoogleAuthenticatorDeleteDeleteGoogleAuthenticatorTokenResponse>('delete',`${this.basePath}/GoogleAuthenticator/DeleteGoogleAuthenticatorToken`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public initPageGetFunctionInitPagePost(body?: CoreModelsAuthenticationFunctionInitPageFunctionInitPageRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationFunctionInitPageFunctionInitPageResponse>;
    public initPageGetFunctionInitPagePost(body?: CoreModelsAuthenticationFunctionInitPageFunctionInitPageRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationFunctionInitPageFunctionInitPageResponse>>;
    public initPageGetFunctionInitPagePost(body?: CoreModelsAuthenticationFunctionInitPageFunctionInitPageRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationFunctionInitPageFunctionInitPageResponse>>;
    public initPageGetFunctionInitPagePost(body?: CoreModelsAuthenticationFunctionInitPageFunctionInitPageRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationFunctionInitPageFunctionInitPageResponse>('post',`${this.basePath}/InitPage/GetFunctionInitPage`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public initPageGetSwissUserInitPagePost(body?: CoreModelsAuthenticationUserInitPageGetSwissUserInitPageRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationUserInitPageGetSwissUserInitPageResponse>;
    public initPageGetSwissUserInitPagePost(body?: CoreModelsAuthenticationUserInitPageGetSwissUserInitPageRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationUserInitPageGetSwissUserInitPageResponse>>;
    public initPageGetSwissUserInitPagePost(body?: CoreModelsAuthenticationUserInitPageGetSwissUserInitPageRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationUserInitPageGetSwissUserInitPageResponse>>;
    public initPageGetSwissUserInitPagePost(body?: CoreModelsAuthenticationUserInitPageGetSwissUserInitPageRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationUserInitPageGetSwissUserInitPageResponse>('post',`${this.basePath}/InitPage/GetSwissUserInitPage`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public logGetAuditLogsByConditionPost(body?: CoreModelsAuthenticationAuditLogGetSecAuditLogsByConditionRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationAuditLogGetSecAuditLogsByConditionResponse>;
    public logGetAuditLogsByConditionPost(body?: CoreModelsAuthenticationAuditLogGetSecAuditLogsByConditionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationAuditLogGetSecAuditLogsByConditionResponse>>;
    public logGetAuditLogsByConditionPost(body?: CoreModelsAuthenticationAuditLogGetSecAuditLogsByConditionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationAuditLogGetSecAuditLogsByConditionResponse>>;
    public logGetAuditLogsByConditionPost(body?: CoreModelsAuthenticationAuditLogGetSecAuditLogsByConditionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationAuditLogGetSecAuditLogsByConditionResponse>('post',`${this.basePath}/Log/GetAuditLogsByCondition`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public rightCreateOrUpdateRightPost(body?: CoreModelsAuthenticationRightCreateOrUpdateRightRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationRightCreateOrUpdateRightResponse>;
    public rightCreateOrUpdateRightPost(body?: CoreModelsAuthenticationRightCreateOrUpdateRightRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationRightCreateOrUpdateRightResponse>>;
    public rightCreateOrUpdateRightPost(body?: CoreModelsAuthenticationRightCreateOrUpdateRightRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationRightCreateOrUpdateRightResponse>>;
    public rightCreateOrUpdateRightPost(body?: CoreModelsAuthenticationRightCreateOrUpdateRightRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationRightCreateOrUpdateRightResponse>('post',`${this.basePath}/Right/CreateOrUpdateRight`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public rightDeleteRightDelete(body?: CoreModelsAuthenticationRightDeleteDeleteRightRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationRightDeleteDeleteRightResponse>;
    public rightDeleteRightDelete(body?: CoreModelsAuthenticationRightDeleteDeleteRightRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationRightDeleteDeleteRightResponse>>;
    public rightDeleteRightDelete(body?: CoreModelsAuthenticationRightDeleteDeleteRightRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationRightDeleteDeleteRightResponse>>;
    public rightDeleteRightDelete(body?: CoreModelsAuthenticationRightDeleteDeleteRightRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationRightDeleteDeleteRightResponse>('delete',`${this.basePath}/Right/DeleteRight`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public rightGetRightByConditionPost(body?: CoreModelsAuthenticationRightGetRightByConditionRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationRightGetRightByConditionResponse>;
    public rightGetRightByConditionPost(body?: CoreModelsAuthenticationRightGetRightByConditionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationRightGetRightByConditionResponse>>;
    public rightGetRightByConditionPost(body?: CoreModelsAuthenticationRightGetRightByConditionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationRightGetRightByConditionResponse>>;
    public rightGetRightByConditionPost(body?: CoreModelsAuthenticationRightGetRightByConditionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationRightGetRightByConditionResponse>('post',`${this.basePath}/Right/GetRightByCondition`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public roleCreateOrUpdateRolePost(body?: CoreModelsAuthenticationRoleCreateOrUpdateRoleRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationRoleCreateOrUpdateRoleResponse>;
    public roleCreateOrUpdateRolePost(body?: CoreModelsAuthenticationRoleCreateOrUpdateRoleRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationRoleCreateOrUpdateRoleResponse>>;
    public roleCreateOrUpdateRolePost(body?: CoreModelsAuthenticationRoleCreateOrUpdateRoleRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationRoleCreateOrUpdateRoleResponse>>;
    public roleCreateOrUpdateRolePost(body?: CoreModelsAuthenticationRoleCreateOrUpdateRoleRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationRoleCreateOrUpdateRoleResponse>('post',`${this.basePath}/Role/CreateOrUpdateRole`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public roleCreateOrUpdateRoleXRightPost(body?: CoreModelsAuthenticationRoleXRightCreateOrUpdateRoleXRightRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationRoleXRightCreateOrUpdateRoleXRightResponse>;
    public roleCreateOrUpdateRoleXRightPost(body?: CoreModelsAuthenticationRoleXRightCreateOrUpdateRoleXRightRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationRoleXRightCreateOrUpdateRoleXRightResponse>>;
    public roleCreateOrUpdateRoleXRightPost(body?: CoreModelsAuthenticationRoleXRightCreateOrUpdateRoleXRightRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationRoleXRightCreateOrUpdateRoleXRightResponse>>;
    public roleCreateOrUpdateRoleXRightPost(body?: CoreModelsAuthenticationRoleXRightCreateOrUpdateRoleXRightRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationRoleXRightCreateOrUpdateRoleXRightResponse>('post',`${this.basePath}/Role/CreateOrUpdateRoleXRight`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public roleDeleteRoleDelete(body?: CoreModelsAuthenticationRoleDeleteDeleteRoleRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationRoleDeleteDeleteRoleResponse>;
    public roleDeleteRoleDelete(body?: CoreModelsAuthenticationRoleDeleteDeleteRoleRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationRoleDeleteDeleteRoleResponse>>;
    public roleDeleteRoleDelete(body?: CoreModelsAuthenticationRoleDeleteDeleteRoleRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationRoleDeleteDeleteRoleResponse>>;
    public roleDeleteRoleDelete(body?: CoreModelsAuthenticationRoleDeleteDeleteRoleRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationRoleDeleteDeleteRoleResponse>('delete',`${this.basePath}/Role/DeleteRole`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public roleDeleteRoleXRightDelete(body?: CoreModelsAuthenticationRoleXRightDeleteDeleteRoleXRightRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationRoleXRightDeleteDeleteRoleXRightResponse>;
    public roleDeleteRoleXRightDelete(body?: CoreModelsAuthenticationRoleXRightDeleteDeleteRoleXRightRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationRoleXRightDeleteDeleteRoleXRightResponse>>;
    public roleDeleteRoleXRightDelete(body?: CoreModelsAuthenticationRoleXRightDeleteDeleteRoleXRightRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationRoleXRightDeleteDeleteRoleXRightResponse>>;
    public roleDeleteRoleXRightDelete(body?: CoreModelsAuthenticationRoleXRightDeleteDeleteRoleXRightRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationRoleXRightDeleteDeleteRoleXRightResponse>('delete',`${this.basePath}/Role/DeleteRoleXRight`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public roleGetRoleByConditionPost(body?: CoreModelsAuthenticationRoleGetRoleByConditionRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationRoleGetRoleByConditionResponse>;
    public roleGetRoleByConditionPost(body?: CoreModelsAuthenticationRoleGetRoleByConditionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationRoleGetRoleByConditionResponse>>;
    public roleGetRoleByConditionPost(body?: CoreModelsAuthenticationRoleGetRoleByConditionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationRoleGetRoleByConditionResponse>>;
    public roleGetRoleByConditionPost(body?: CoreModelsAuthenticationRoleGetRoleByConditionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationRoleGetRoleByConditionResponse>('post',`${this.basePath}/Role/GetRoleByCondition`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userCreateOrUpdatePasswordChangeRequestPost(body?: CoreModelsAuthenticationPasswordPasswordChangeRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationPasswordPasswordChangeResponse>;
    public userCreateOrUpdatePasswordChangeRequestPost(body?: CoreModelsAuthenticationPasswordPasswordChangeRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationPasswordPasswordChangeResponse>>;
    public userCreateOrUpdatePasswordChangeRequestPost(body?: CoreModelsAuthenticationPasswordPasswordChangeRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationPasswordPasswordChangeResponse>>;
    public userCreateOrUpdatePasswordChangeRequestPost(body?: CoreModelsAuthenticationPasswordPasswordChangeRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationPasswordPasswordChangeResponse>('post',`${this.basePath}/User/CreateOrUpdatePasswordChangeRequest`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userCreateOrUpdateSwissUserPost(body?: CoreModelsAuthenticationUserCreateOrUpdateSwissUserRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationUserCreateOrUpdateSwissUserResponse>;
    public userCreateOrUpdateSwissUserPost(body?: CoreModelsAuthenticationUserCreateOrUpdateSwissUserRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationUserCreateOrUpdateSwissUserResponse>>;
    public userCreateOrUpdateSwissUserPost(body?: CoreModelsAuthenticationUserCreateOrUpdateSwissUserRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationUserCreateOrUpdateSwissUserResponse>>;
    public userCreateOrUpdateSwissUserPost(body?: CoreModelsAuthenticationUserCreateOrUpdateSwissUserRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationUserCreateOrUpdateSwissUserResponse>('post',`${this.basePath}/User/CreateOrUpdateSwissUser`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userCreateOrUpdateSwissUserXRolePost(body?: CoreModelsAuthenticationSwissUserXRoleCreateOrUpdateSwissUserXRoleRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationSwissUserXRoleCreateOrUpdateSwissUserXRoleResponse>;
    public userCreateOrUpdateSwissUserXRolePost(body?: CoreModelsAuthenticationSwissUserXRoleCreateOrUpdateSwissUserXRoleRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationSwissUserXRoleCreateOrUpdateSwissUserXRoleResponse>>;
    public userCreateOrUpdateSwissUserXRolePost(body?: CoreModelsAuthenticationSwissUserXRoleCreateOrUpdateSwissUserXRoleRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationSwissUserXRoleCreateOrUpdateSwissUserXRoleResponse>>;
    public userCreateOrUpdateSwissUserXRolePost(body?: CoreModelsAuthenticationSwissUserXRoleCreateOrUpdateSwissUserXRoleRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationSwissUserXRoleCreateOrUpdateSwissUserXRoleResponse>('post',`${this.basePath}/User/CreateOrUpdateSwissUserXRole`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userCreateOrUpdateUserPost(body?: CoreModelsAuthenticationUserCreateOrUpdateSwissUserWithPasswordRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationUserCreateOrUpdateSwissUserWithPasswordResponse>;
    public userCreateOrUpdateUserPost(body?: CoreModelsAuthenticationUserCreateOrUpdateSwissUserWithPasswordRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationUserCreateOrUpdateSwissUserWithPasswordResponse>>;
    public userCreateOrUpdateUserPost(body?: CoreModelsAuthenticationUserCreateOrUpdateSwissUserWithPasswordRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationUserCreateOrUpdateSwissUserWithPasswordResponse>>;
    public userCreateOrUpdateUserPost(body?: CoreModelsAuthenticationUserCreateOrUpdateSwissUserWithPasswordRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationUserCreateOrUpdateSwissUserWithPasswordResponse>('post',`${this.basePath}/User/CreateOrUpdateUser`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userDeleteFunctionDelete(body?: CoreModelsAuthenticationFunctionDeleteDeleteFunctionRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationFunctionDeleteDeleteFunctionResponse>;
    public userDeleteFunctionDelete(body?: CoreModelsAuthenticationFunctionDeleteDeleteFunctionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationFunctionDeleteDeleteFunctionResponse>>;
    public userDeleteFunctionDelete(body?: CoreModelsAuthenticationFunctionDeleteDeleteFunctionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationFunctionDeleteDeleteFunctionResponse>>;
    public userDeleteFunctionDelete(body?: CoreModelsAuthenticationFunctionDeleteDeleteFunctionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationFunctionDeleteDeleteFunctionResponse>('delete',`${this.basePath}/User/DeleteFunction`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userDeleteSwissUserXRoleDelete(body?: CoreModelsAuthenticationSwissUserXRoleDeleteSwissUserXRoleRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationSwissUserXRoleDeleteSwissUserXRoleResponse>;
    public userDeleteSwissUserXRoleDelete(body?: CoreModelsAuthenticationSwissUserXRoleDeleteSwissUserXRoleRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationSwissUserXRoleDeleteSwissUserXRoleResponse>>;
    public userDeleteSwissUserXRoleDelete(body?: CoreModelsAuthenticationSwissUserXRoleDeleteSwissUserXRoleRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationSwissUserXRoleDeleteSwissUserXRoleResponse>>;
    public userDeleteSwissUserXRoleDelete(body?: CoreModelsAuthenticationSwissUserXRoleDeleteSwissUserXRoleRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationSwissUserXRoleDeleteSwissUserXRoleResponse>('delete',`${this.basePath}/User/DeleteSwissUserXRole`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userDeleteUserDelete(body?: CoreModelsAuthenticationUserDeleteDeleteUserRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationUserDeleteDeleteUserResponse>;
    public userDeleteUserDelete(body?: CoreModelsAuthenticationUserDeleteDeleteUserRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationUserDeleteDeleteUserResponse>>;
    public userDeleteUserDelete(body?: CoreModelsAuthenticationUserDeleteDeleteUserRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationUserDeleteDeleteUserResponse>>;
    public userDeleteUserDelete(body?: CoreModelsAuthenticationUserDeleteDeleteUserRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationUserDeleteDeleteUserResponse>('delete',`${this.basePath}/User/DeleteUser`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userGetClinicsByUserIdPost(body?: CoreModelsAuthenticationSwissUserXRoleGetClinicsByUserIdRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationSwissUserXRoleGetClinicsByUserIdReponse>;
    public userGetClinicsByUserIdPost(body?: CoreModelsAuthenticationSwissUserXRoleGetClinicsByUserIdRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationSwissUserXRoleGetClinicsByUserIdReponse>>;
    public userGetClinicsByUserIdPost(body?: CoreModelsAuthenticationSwissUserXRoleGetClinicsByUserIdRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationSwissUserXRoleGetClinicsByUserIdReponse>>;
    public userGetClinicsByUserIdPost(body?: CoreModelsAuthenticationSwissUserXRoleGetClinicsByUserIdRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationSwissUserXRoleGetClinicsByUserIdReponse>('post',`${this.basePath}/User/GetClinicsByUserId`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userGetSwissUserByConditionPost(body?: CoreModelsAuthenticationUserGetSwissUserByConditionRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationUserGetSwissUserByConditionResponse>;
    public userGetSwissUserByConditionPost(body?: CoreModelsAuthenticationUserGetSwissUserByConditionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationUserGetSwissUserByConditionResponse>>;
    public userGetSwissUserByConditionPost(body?: CoreModelsAuthenticationUserGetSwissUserByConditionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationUserGetSwissUserByConditionResponse>>;
    public userGetSwissUserByConditionPost(body?: CoreModelsAuthenticationUserGetSwissUserByConditionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationUserGetSwissUserByConditionResponse>('post',`${this.basePath}/User/GetSwissUserByCondition`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userGetSwissUserXRoleByConditionPost(body?: CoreModelsAuthenticationSwissUserXRoleGetSwissUserXRoleByConditionRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationSwissUserXRoleGetSwissUserXRoleByConditionResponse>;
    public userGetSwissUserXRoleByConditionPost(body?: CoreModelsAuthenticationSwissUserXRoleGetSwissUserXRoleByConditionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationSwissUserXRoleGetSwissUserXRoleByConditionResponse>>;
    public userGetSwissUserXRoleByConditionPost(body?: CoreModelsAuthenticationSwissUserXRoleGetSwissUserXRoleByConditionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationSwissUserXRoleGetSwissUserXRoleByConditionResponse>>;
    public userGetSwissUserXRoleByConditionPost(body?: CoreModelsAuthenticationSwissUserXRoleGetSwissUserXRoleByConditionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationSwissUserXRoleGetSwissUserXRoleByConditionResponse>('post',`${this.basePath}/User/GetSwissUserXRoleByCondition`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userResetPasswordPost(body?: CoreModelsAuthenticationPasswordResetPasswordRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationPasswordResetPasswordResponse>;
    public userResetPasswordPost(body?: CoreModelsAuthenticationPasswordResetPasswordRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationPasswordResetPasswordResponse>>;
    public userResetPasswordPost(body?: CoreModelsAuthenticationPasswordResetPasswordRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationPasswordResetPasswordResponse>>;
    public userResetPasswordPost(body?: CoreModelsAuthenticationPasswordResetPasswordRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationPasswordResetPasswordResponse>('post',`${this.basePath}/User/ResetPassword`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userSetPasswordPost(body?: CoreModelsAuthenticationPasswordSetPasswordRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationPasswordSetPasswordResponse>;
    public userSetPasswordPost(body?: CoreModelsAuthenticationPasswordSetPasswordRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationPasswordSetPasswordResponse>>;
    public userSetPasswordPost(body?: CoreModelsAuthenticationPasswordSetPasswordRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationPasswordSetPasswordResponse>>;
    public userSetPasswordPost(body?: CoreModelsAuthenticationPasswordSetPasswordRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationPasswordSetPasswordResponse>('post',`${this.basePath}/User/SetPassword`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userSetPasswordToDefaultPost(body?: CoreModelsAuthenticationPasswordSetPasswordToDefaultRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationPasswordSetPasswordToDefaultResponse>;
    public userSetPasswordToDefaultPost(body?: CoreModelsAuthenticationPasswordSetPasswordToDefaultRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationPasswordSetPasswordToDefaultResponse>>;
    public userSetPasswordToDefaultPost(body?: CoreModelsAuthenticationPasswordSetPasswordToDefaultRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationPasswordSetPasswordToDefaultResponse>>;
    public userSetPasswordToDefaultPost(body?: CoreModelsAuthenticationPasswordSetPasswordToDefaultRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationPasswordSetPasswordToDefaultResponse>('post',`${this.basePath}/User/SetPasswordToDefault`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userUserIDCheckExistsPost(body?: CoreModelsAuthenticationUserUserIDCheckExistsRequest, observe?: 'body', reportProgress?: boolean): Observable<CoreModelsAuthenticationUserUserIDCheckExistsResponse>;
    public userUserIDCheckExistsPost(body?: CoreModelsAuthenticationUserUserIDCheckExistsRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CoreModelsAuthenticationUserUserIDCheckExistsResponse>>;
    public userUserIDCheckExistsPost(body?: CoreModelsAuthenticationUserUserIDCheckExistsRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CoreModelsAuthenticationUserUserIDCheckExistsResponse>>;
    public userUserIDCheckExistsPost(body?: CoreModelsAuthenticationUserUserIDCheckExistsRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<CoreModelsAuthenticationUserUserIDCheckExistsResponse>('post',`${this.basePath}/User/UserIDCheckExists`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webServiceInfoGetEndpointListGet(observe?: 'body', reportProgress?: boolean): Observable<Array<CoreModelsWebServiceBaseEndpointListResponse>>;
    public webServiceInfoGetEndpointListGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CoreModelsWebServiceBaseEndpointListResponse>>>;
    public webServiceInfoGetEndpointListGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CoreModelsWebServiceBaseEndpointListResponse>>>;
    public webServiceInfoGetEndpointListGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<CoreModelsWebServiceBaseEndpointListResponse>>('get',`${this.basePath}/WebServiceInfo/GetEndpointList`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
